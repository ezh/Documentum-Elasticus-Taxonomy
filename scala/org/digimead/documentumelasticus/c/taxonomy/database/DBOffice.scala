/*
 *
 * This file is part of the Documentum Elasticus project.
 * Copyright (c) 2010-2011 Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS»
 * Author: Alexey Aksenov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Global License version 3
 * as published by the Free Software Foundation with the addition of the
 * following permission added to Section 15 as permitted in Section 7(a):
 * FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED
 * BY Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS»,
 * Limited Liability Company «MEZHGALAKTICHESKIJ TORGOVYJ ALIANS» DISCLAIMS
 * THE WARRANTY OF NON INFRINGEMENT OF THIRD PARTY RIGHTS.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Global License for more details.
 * You should have received a copy of the GNU Affero General Global License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA, 02110-1301 USA, or download the license from the following URL:
 * http://www.gnu.org/licenses/agpl.html
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Global License.
 *
 * In accordance with Section 7(b) of the GNU Affero General Global License,
 * you must retain the producer line in every report, form or document
 * that is created or manipulated using Documentum Elasticus.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the Documentum Elasticus software without
 * disclosing the source code of your own applications.
 * These activities include: offering paid services to customers,
 * serving files in a web or/and network application,
 * shipping Documentum Elasticus with a closed source product.
 *
 * For more information, please contact Documentum Elasticus Team at this
 * address: ezh@ezh.msk.ru
 *
 */

package org.digimead.documentumelasticus.c.taxonomy.database

import com.sun.star.util.DateTime
import java.sql.ResultSet
import java.sql.Types
import java.util.UUID
import org.digimead.documentumelasticus.c.Taxonomy
import org.digimead.documentumelasticus.database.XDBUtils
import org.digimead.documentumelasticus.database.XDatabase
import org.digimead.documentumelasticus.helper.DT
import org.digimead.documentumelasticus.storage.XFile
import org.slf4j.LoggerFactory

class DBOffice(database: XDatabase) extends DB with XDBUtils {
  override val logger = LoggerFactory.getLogger(this.getClass)
  val connection = database.connection
  val sTaxonomyCategoryTable = addTablePrefix("_TAXONOMY_CATEGORY")
  val sTaxonomyDocumentTable = addTablePrefix("_TAXONOMY_DOCUMENT")
  val sTaxonomyFileTable = addTablePrefix("_TAXONOMY_FILE")
  val sFileTable = addTablePrefix("FILE")
  def fixDataSource(): Boolean = {
    var result: Boolean = true
    val md = connection.getMetaData()
    val statement = connection.createStatement()
    logger.info("check database version of " + Taxonomy.componentName)
    val versionRow = selectRow(connection, "SELECT VALUE FROM METADATA WHERE KEY='" + Taxonomy.componentName + "_VERSION'")
    val version: String = if (versionRow.length == 0) {
      statement.executeUpdate("INSERT INTO METADATA VALUES ('" + Taxonomy.componentName + "_VERSION', '0')")
      "0"
    } else {
      versionRow(0).asInstanceOf[String]
    }
    logger.info("database version: " + version)
    if (version.toInt < 2011032600)
      result = fixDataSourceNullTo20110326()
    statement.close()
    true
  }
  private def fixDataSourceNullTo20110326(): Boolean = {
    val md = connection.getMetaData()
    val statement = connection.createStatement()
    // component tables
    val newVersion = 2011032601
    val version = selectRow(connection, "SELECT VALUE FROM METADATA WHERE KEY='" + Taxonomy.componentName + "_VERSION'")(0).asInstanceOf[String]
    logger.info("update component database from version " + version + " to " + newVersion)
    /*
     * CATEGORY
     */
    if (!md.getTables(null, null, sTaxonomyCategoryTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE \"" + sTaxonomyCategoryTable + "\"\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"parent_id\" BIGINT,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"name\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"owner_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"created_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"updated_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "FOREIGN KEY (\"parent_id\") REFERENCES \"" + sTaxonomyCategoryTable + "\"(\"id\"),\n"
      sCreateStatement += "UNIQUE (\"name\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sTaxonomyCategoryTable))
        return false
    }
    /*
     * DOCUMENT
     */
    if (!md.getTables(null, null, sTaxonomyDocumentTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE \"" + sTaxonomyDocumentTable + "\"\n"
      sCreateStatement += "(\"id\" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,\n"
      sCreateStatement += "\"category_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"uuid\" VARCHAR_IGNORECASE(36) NOT NULL,\n"
      sCreateStatement += "\"name\" VARCHAR_IGNORECASE(256) NOT NULL,\n"
      sCreateStatement += "\"owner_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"group_id\" BIGINT,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"created_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"updated_at\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "FOREIGN KEY (\"category_id\") REFERENCES \"" + sTaxonomyCategoryTable + "\"(\"id\"),\n"
      sCreateStatement += "UNIQUE (\"name\"),\n"
      sCreateStatement += "UNIQUE (\"uuid\"))"
      if (!createTable(connection, sCreateStatement, sTaxonomyDocumentTable))
        return false
    }
    /*
     * DOCUMENTFILE
     */
    if (!md.getTables(null, null, sTaxonomyFileTable, Array("TABLE")).next()) {
      var sCreateStatement = "CREATE TABLE \"" + sTaxonomyFileTable + "\"\n"
      sCreateStatement += "(\"document_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"file_id\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_user\" BIGINT NOT NULL,\n"
      sCreateStatement += "\"last_time\" DATETIME NOT NULL,\n"
      sCreateStatement += "\"description\" VARCHAR_IGNORECASE(4096) DEFAULT '' NOT NULL,\n"
      sCreateStatement += "\"timestamp\" TIMESTAMP NOT NULL,\n"
      sCreateStatement += "FOREIGN KEY (\"document_id\") REFERENCES \"" + sTaxonomyDocumentTable + "\"(\"id\"),\n"
      sCreateStatement += "FOREIGN KEY (\"file_id\") REFERENCES \"" + sFileTable + "\"(\"id\"),\n"
      sCreateStatement += "UNIQUE (\"document_id\", \"file_id\"))"
      if (!createTable(connection, sCreateStatement, sTaxonomyFileTable))
        return false
    }
    statement.executeUpdate("UPDATE METADATA SET VALUE='" + newVersion + "' WHERE KEY='" + Taxonomy.componentName + "_VERSION'")
    statement.close()
    true
  }
  def documentCreate(name: String, date: DateTime, description: String): Long = {
    val statement = connection.prepareStatement("INSERT INTO \"" + sTaxonomyDocumentTable + "\" ("
                                                    +"\"uuid\", \"name\", \"owner_id\", \"group_id\","
                                                    +"\"last_user\", \"last_time\", \"description\","
                                                    +"\"created_at\", \"updated_at\", \"timestamp\") VALUES ("
                                                    +"?, ?, ?, ?, ?, now, ?, now, ?, now)"
    )
    val uuid = UUID.randomUUID()
    val user = Taxonomy.core.getUser()
    val group = user.getGroup()
    statement.setString(1, uuid.toString)
    statement.setString(2, name)
    statement.setLong(3, user.getID())
    if (group == null || group.getID() == 0) {
      statement.setNull(4, Types.BIGINT)
    } else {
      statement.setLong(4, group.getID())
    }
    statement.setLong(5, user.getID())
    statement.setString(6, description)
    statement.setTimestamp(7, DT.toTimestamp(date))
    statement.executeUpdate()
    statement.close()
    val resultset = documentGet("\"id\"", "WHERE \"uuid\" = ?", Array(uuid.toString))
    if (!resultset.next()) {
      throw new RuntimeException("New document with UUID = " + uuid.toString + " not found")
    }
    val result = resultset.getLong(1)
    resultset.getStatement.close()
    result
  }
  def documentAddFile(id: Long, file_id: Long, description: String) {
    val statement = connection.prepareStatement("INSERT INTO \"" + sTaxonomyFileTable + "\" ("
                                                    +"\"document_id\", \"file_id\","
                                                    +"\"last_user\", \"last_time\", \"description\","
                                                    +"\"timestamp\") VALUES ("
                                                    +"?, ?, ?, now, ?, now)"
    )
    val user = Taxonomy.core.getUser()
    statement.setLong(1, id)
    statement.setLong(2, file_id)
    statement.setLong(3, user.getID())
    statement.setString(4, description)
    statement.executeUpdate()
    statement.close()
  }
  def documentGet(sqlFields: String, sqlConstraint: String, args: Array[Any] = Array()): ResultSet = {
    val statement = connection.prepareStatement("SELECT " + sqlFields + " FROM \"" + sTaxonomyDocumentTable + "\" " + sqlConstraint)
    addStatementParameters(statement, args)
    statement.executeQuery()
  }
}
